#include <stdio.h>
#include <string>
#include <vector>
 
using std::string;
using std::vector;
 
// IMPORTANT: DO NOT MODIFY THIS CLASS
class Employee {
private:
    const int id;
    const string name;
    vector<Employee*> reports;
 
public:
    Employee(int id, string name) : id(id), name(name) {
    }
 
    int getId() {
        return id;
    }
 
    vector<Employee*>& getReports() {
        return reports;
    }
 
    void addReport(Employee* employee) {
        reports.push_back(employee);
    }
};
 
/*
 * Read the attached PDF for more explanation about the problem
 * Note: Don't modify the signature of this function
 * @param ceo
 * @param firstEmployee
 *
 * @param secondEmployee
 *
 * @return common manager for both the employee that is closest to them.
 *
 * Assumptions 1: There is no employee who reports to more than one managers, in other words the managing relations can be viewed as a tree
 * Assumptions 1: firstEmployee and secondEmployee are in the tree. If only one of them is in the tree, then this function returns one of the two employees who is in the tree. If neither of them is in the tree, this function returns NULL
 *
 * Run time complexity: O(n) n is the number of all employees in the tree
 * Spatial complexity: O(n) n is the number of all employees in the tree
 *
 * This function searches for closest common manager in bottom up fashion. 
 * If current employee (ceo) is the first or second employee, then returns him
 * If current employee manages two employees each of whom returns either first or second employee, then the current employee is the closest common manager
 * If current employee manages one employee that return a pointer that is not NULL and not either first or second employee, then the current employee is higher than the closest common manager. 
 */
static Employee* closestCommonManager(Employee* ceo, Employee* firstEmployee, Employee* secondEmployee) {
    // Implement me
    if(!ceo) 
        return NULL;
    if(firstEmployee == ceo || secondEmployee == ceo)
        return ceo;
    vector<Employee*> employees;
    for(int i=0; i<ceo->getReports().size(); i++)
        employees.push_back(closestCommonManager(ceo->getReports()[i], firstEmployee, secondEmployee));
    int found = 0;
    Employee* someEmployee = NULL;
    Employee* manager = NULL;
    if(ceo->getId() == 1)
        printf("abc\n");
    for(int i=0; i<employees.size(); i++){
        if(!employees[i]) continue;
        manager = employees[i];
        if(employees[i]->getId() == firstEmployee->getId() || employees[i]->getId() == secondEmployee->getId()){
            found++;
            someEmployee = employees[i];
        }
    }
    if(found == 2)
        return ceo;
    else if(found == 1)
        return someEmployee;
    else
        return employees.size() == 0?NULL:manager;
}
