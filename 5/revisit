/*
Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.

For "(()", the longest valid parentheses substring is "()", which has length = 2.

Another example is ")()())", where the longest valid parentheses substring is "()()", which has length = 4.
*/

#include "header.h"

/*
int longestValidParentheses(string s) {
    int sz = s.length();
    if(sz<2) return 0;
    stack<int> stack;
    int res = 0;
    stack.push(-1);
    for(int i=0; i<sz; i++){
        if(s[i] == '(') stack.push(i);
        else if(stack.top() != -1 && s[stack.top()]=='('){
            stack.pop();
            res = max(res, i-stack.top());
        }
        else stack.push(i);
    }
    return res;
}
*/
int longestValidParentheses(string s) {
    int sz = s.length();
    if(sz<2) return 0;
    stack<int> stack;
    int res = 0;
    int begin = -1;
    for(int i=0; i<sz; i++){
        if(s[i] == '(') stack.push(i);
        else{
            if(stack.empty()){
                begin = i;
                continue;
            } 
            stack.pop();
            if(stack.empty())
                res = max(res,i-begin);
            else
                res = max(res, i-stack.top());
        }
    }
    return res;
}

int main(){
    //string s0("()(()))()())");
    string s0("()(())");
    printf("%d\n", longestValidParentheses(s0));
    string s1("(()");
    printf("%d\n", longestValidParentheses(s1));
    string s2("");
    printf("%d\n", longestValidParentheses(s2));
    return 0;
}
search_in_rotated_sorted_array.cpp
wildcard_match.cpp
permutations_ii.cpp
insert_interval.cpp
permutation_seq.cpp
valid_number.cpp
text_justification.cpp
minimum_window_substring.cpp
largest_rectangle_in_histogram.cpp
max_rectangle.cpp
restore_ip_address.cpp
max_depth_of_binary_tree.cpp
gas_station.cpp
lca_print_path.cpp
/*
Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete at most k transactions.

Note:
You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).
*/

#include "header.h"

int solvePrices(vector<int>& prices){
    int res = 0;
    int sz = prices.size();
    for(int i=1; i<sz; i++){
        if(prices[i]>prices[i-1]) res+=prices[i]-prices[i-1];
    }
    return res;
}

int maxProfit(int k, vector<int>& prices){
    if(k == 0) return 0;
    int sz = prices.size();
    if(k>=sz) return solvePrices(prices);
    if(sz < 2) return 0;
    int local[k+1][sz];
    int global[k+1][sz];
    memset(local, 0, sizeof(local));
    memset(global, 0, sizeof(global));
    for(int i=1; i<sz; i++){
        int diff = prices[i] - prices[i-1];
        for(int j = 1; j<=k; j++){
            local[j][i] = max(
                    global[j-1][i-1]+max(diff, 0),
                    local[j][i-1]+diff
                    );
            global[j][i] = max(
                    global[j][i-1],
                    local[j][i]
                    );
        }
    }
    return global[k][sz-1];
}

int main(){
    int arr[] = {}
    return 0;
}